"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unsupportedVarDeclaration = exports.unresolvableRequirePath = exports.invalidAmbientIdentifierName = exports.unsupportedProperty = exports.unsupportedForTarget = exports.unsupportedRightShiftOperator = exports.unsupportedAccessorInObjectLiteral = exports.luaIteratorForbiddenUsage = exports.luaTableForbiddenUsage = exports.luaTableCannotBeAccessedDynamically = exports.luaTableInvalidInstanceOf = exports.luaTableCannotBeExtended = exports.luaTableMustBeAmbient = exports.invalidForRangeCall = exports.metaExtensionMissingExtends = exports.extensionAndMetaExtensionConflict = exports.extensionInvalidInstanceOf = exports.extensionCannotExport = exports.extensionCannotExtend = exports.extensionCannotConstruct = exports.annotationInvalidArgumentCount = exports.decoratorInvalidContext = exports.unsupportedOverloadAssignment = exports.unsupportedSelfFunctionConversion = exports.unsupportedNoSelfFunctionConversion = exports.forbiddenForIn = exports.unsupportedNodeKind = void 0;
const ts = require("typescript");
const CompilerOptions_1 = require("../../CompilerOptions");
const utils_1 = require("../../utils");
const createDiagnosticFactory = (message) => utils_1.createSerialDiagnosticFactory((node, ...args) => ({
    file: node.getSourceFile(),
    start: node.getStart(),
    length: node.getWidth(),
    messageText: typeof message === "string" ? message : message(...args),
}));
exports.unsupportedNodeKind = createDiagnosticFactory((kind) => `Unsupported node kind ${ts.SyntaxKind[kind]}`);
exports.forbiddenForIn = createDiagnosticFactory("Iterating over arrays with 'for ... in' is not allowed.");
exports.unsupportedNoSelfFunctionConversion = createDiagnosticFactory((name) => {
    const nameReference = name ? ` '${name}'` : "";
    return (`Unable to convert function with a 'this' parameter to function${nameReference} with no 'this'. ` +
        "To fix, wrap in an arrow function, or declare with 'this: void'.");
});
exports.unsupportedSelfFunctionConversion = createDiagnosticFactory((name) => {
    const nameReference = name ? ` '${name}'` : "";
    return (`Unable to convert function with no 'this' parameter to function${nameReference} with 'this'. ` +
        "To fix, wrap in an arrow function, or declare with 'this: any'.");
});
exports.unsupportedOverloadAssignment = createDiagnosticFactory((name) => {
    const nameReference = name ? ` to '${name}'` : "";
    return (`Unsupported assignment of function with different overloaded types for 'this'${nameReference}. ` +
        "Overloads should all have the same type for 'this'.");
});
exports.decoratorInvalidContext = createDiagnosticFactory("Decorator function cannot have 'this: void'.");
exports.annotationInvalidArgumentCount = createDiagnosticFactory((kind, got, expected) => `'@${kind}' expects ${expected} arguments, but got ${got}.`);
exports.extensionCannotConstruct = createDiagnosticFactory("Cannot construct classes with '@extension' or '@metaExtension' annotation.");
exports.extensionCannotExtend = createDiagnosticFactory("Cannot extend classes with '@extension' or '@metaExtension' annotation.");
exports.extensionCannotExport = createDiagnosticFactory("Cannot export classes with '@extension' or '@metaExtension' annotation.");
exports.extensionInvalidInstanceOf = createDiagnosticFactory("Cannot use instanceof on classes with '@extension' or '@metaExtension' annotation.");
exports.extensionAndMetaExtensionConflict = createDiagnosticFactory("Cannot use both '@extension' and '@metaExtension' annotations on the same class.");
exports.metaExtensionMissingExtends = createDiagnosticFactory("'@metaExtension' annotation requires the extension of the metatable class.");
exports.invalidForRangeCall = createDiagnosticFactory((message) => `Invalid @forRange call: ${message}.`);
exports.luaTableMustBeAmbient = createDiagnosticFactory("Classes with the '@luaTable' annotation must be ambient.");
exports.luaTableCannotBeExtended = createDiagnosticFactory("Cannot extend classes with the '@luaTable' annotation.");
exports.luaTableInvalidInstanceOf = createDiagnosticFactory("The instanceof operator cannot be used with a '@luaTable' class.");
exports.luaTableCannotBeAccessedDynamically = createDiagnosticFactory("@luaTable cannot be accessed dynamically.");
exports.luaTableForbiddenUsage = createDiagnosticFactory((description) => `Invalid @luaTable usage: ${description}.`);
exports.luaIteratorForbiddenUsage = createDiagnosticFactory("Unsupported use of lua iterator with '@tupleReturn' annotation in for...of statement. " +
    "You must use a destructuring statement to catch results from a lua iterator with " +
    "the '@tupleReturn' annotation.");
exports.unsupportedAccessorInObjectLiteral = createDiagnosticFactory("Accessors in object literal are not supported.");
exports.unsupportedRightShiftOperator = createDiagnosticFactory("Right shift operator is not supported for target Lua 5.3. Use `>>>` instead.");
const getLuaTargetName = (version) => (version === CompilerOptions_1.LuaTarget.LuaJIT ? "LuaJIT" : `Lua ${version}`);
exports.unsupportedForTarget = createDiagnosticFactory((functionality, version) => `${functionality} is/are not supported for target ${getLuaTargetName(version)}.`);
exports.unsupportedProperty = createDiagnosticFactory((parentName, property) => `${parentName}.${property} is unsupported.`);
exports.invalidAmbientIdentifierName = createDiagnosticFactory((text) => `Invalid ambient identifier name '${text}'. Ambient identifiers must be valid lua identifiers.`);
exports.unresolvableRequirePath = createDiagnosticFactory((path) => `Cannot create require path. Module '${path}' does not exist within --rootDir.`);
exports.unsupportedVarDeclaration = createDiagnosticFactory("`var` declarations are not supported. Use `let` or `const` instead.");
//# sourceMappingURL=diagnostics.js.map