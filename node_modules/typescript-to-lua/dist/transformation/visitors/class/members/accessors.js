"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isGetAccessorOverride = exports.hasMemberInClassOrAncestor = exports.transformAccessorDeclarations = void 0;
const ts = require("typescript");
const lua = require("../../../../LuaAST");
const lua_ast_1 = require("../../../utils/lua-ast");
const lualib_1 = require("../../../utils/lualib");
const function_1 = require("../../function");
const literal_1 = require("../../literal");
const utils_1 = require("../utils");
const constructor_1 = require("./constructor");
function transformAccessor(context, node) {
    const [params, dot, restParam] = function_1.transformParameters(context, node.parameters, lua_ast_1.createSelfIdentifier());
    const body = node.body ? function_1.transformFunctionBody(context, node.parameters, node.body, restParam)[0] : [];
    return lua.createFunctionExpression(lua.createBlock(body), params, dot, lua.FunctionExpressionFlags.Declaration);
}
function transformAccessorDeclarations(context, { firstAccessor, getAccessor, setAccessor }, className) {
    const propertyName = literal_1.transformPropertyName(context, firstAccessor.name);
    const descriptor = lua.createTableExpression([]);
    if (getAccessor) {
        const getterFunction = transformAccessor(context, getAccessor);
        descriptor.fields.push(lua.createTableFieldExpression(getterFunction, lua.createStringLiteral("get")));
    }
    if (setAccessor) {
        const setterFunction = transformAccessor(context, setAccessor);
        descriptor.fields.push(lua.createTableFieldExpression(setterFunction, lua.createStringLiteral("set")));
    }
    const isStatic = utils_1.isStaticNode(firstAccessor);
    const target = isStatic ? lua.cloneIdentifier(className) : constructor_1.createPrototypeName(className);
    const feature = isStatic ? lualib_1.LuaLibFeature.ObjectDefineProperty : lualib_1.LuaLibFeature.SetDescriptor;
    const parameters = [target, propertyName, descriptor];
    if (!isStatic)
        parameters.push(lua.createBooleanLiteral(true));
    const call = lualib_1.transformLuaLibFunction(context, feature, undefined, ...parameters);
    return lua.createExpressionStatement(call);
}
exports.transformAccessorDeclarations = transformAccessorDeclarations;
function* classWithAncestors(context, classDeclaration) {
    yield classDeclaration;
    const extendsType = utils_1.getExtendedType(context, classDeclaration);
    if (!extendsType) {
        return false;
    }
    const symbol = extendsType.getSymbol();
    if (symbol === undefined) {
        return false;
    }
    const symbolDeclarations = symbol.getDeclarations();
    if (symbolDeclarations === undefined) {
        return false;
    }
    const declaration = symbolDeclarations.find(ts.isClassLike);
    if (!declaration) {
        return false;
    }
    yield* classWithAncestors(context, declaration);
}
exports.hasMemberInClassOrAncestor = (context, classDeclaration, callback) => [...classWithAncestors(context, classDeclaration)].some(c => c.members.some(callback));
function getPropertyName(propertyName) {
    if (ts.isIdentifier(propertyName) || ts.isStringLiteral(propertyName) || ts.isNumericLiteral(propertyName)) {
        return propertyName.text;
    }
    else {
        return undefined; // TODO: how to handle computed property names?
    }
}
function isSamePropertyName(a, b) {
    const aName = getPropertyName(a);
    const bName = getPropertyName(b);
    return aName !== undefined && aName === bName;
}
function isGetAccessorOverride(context, element, classDeclaration) {
    if (!ts.isGetAccessor(element) || utils_1.isStaticNode(element)) {
        return false;
    }
    return exports.hasMemberInClassOrAncestor(context, classDeclaration, m => ts.isPropertyDeclaration(m) && m.initializer !== undefined && isSamePropertyName(m.name, element.name));
}
exports.isGetAccessorOverride = isGetAccessorOverride;
//# sourceMappingURL=accessors.js.map